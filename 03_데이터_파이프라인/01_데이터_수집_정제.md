# Chapter 3.1: 데이터 수집 & 정제

## 개요

VLM Fine-tuning을 위한 데이터 파이프라인 구축 방법을 다룬다. 데이터 수집, 어노테이션, 품질 관리 전략을 포함한다.

---

## 1. 데이터 수집 전략

### 1.1 데이터 소스

| 소스 | 장점 | 단점 | 예시 |
|------|------|------|------|
| **공개 데이터셋** | 즉시 사용 가능, 검증됨 | 도메인 제한 | DocVQA, COCO |
| **웹 크롤링** | 대규모 수집 가능 | 품질 불균일, 저작권 | Common Crawl |
| **합성 데이터** | 커스텀 가능, 확장성 | 도메인 갭 | 템플릿 기반 생성 |
| **자체 수집** | 도메인 적합 | 비용, 시간 | 스캔, 사진 |

### 1.2 의료 문서 데이터 수집

```python
import os
from pathlib import Path
from dataclasses import dataclass
from typing import List, Optional
import hashlib

@dataclass
class DocumentSample:
    """문서 샘플 데이터 구조"""
    image_path: str
    document_type: str  # 진단서, 처방전, 영수증 등
    ground_truth: dict
    metadata: dict
    quality_score: Optional[float] = None

class MedicalDocumentCollector:
    """의료 문서 수집 파이프라인"""

    DOCUMENT_TYPES = ["진단서", "처방전", "영수증", "검사결과지", "소견서"]

    def __init__(self, output_dir: str):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def collect_from_scanner(self, scanner_path: str) -> List[DocumentSample]:
        """스캐너에서 문서 수집"""
        samples = []
        for file_path in Path(scanner_path).glob("*.pdf"):
            # PDF를 이미지로 변환
            images = self._pdf_to_images(file_path)

            for i, img in enumerate(images):
                sample = self._create_sample(img, file_path.stem, i)
                samples.append(sample)

        return samples

    def _create_sample(self, image, doc_id: str, page_num: int) -> DocumentSample:
        """샘플 생성 및 저장"""
        # 파일명 생성 (해시 기반)
        img_bytes = image.tobytes()
        file_hash = hashlib.md5(img_bytes).hexdigest()[:8]
        filename = f"{doc_id}_p{page_num}_{file_hash}.png"

        # 저장
        save_path = self.output_dir / filename
        image.save(save_path)

        return DocumentSample(
            image_path=str(save_path),
            document_type="unknown",  # 추후 분류
            ground_truth={},          # 추후 어노테이션
            metadata={
                "source_doc": doc_id,
                "page_num": page_num,
                "width": image.width,
                "height": image.height
            }
        )

    def _pdf_to_images(self, pdf_path: str, dpi: int = 300) -> List:
        """PDF를 이미지로 변환"""
        import fitz  # PyMuPDF

        doc = fitz.open(pdf_path)
        images = []

        for page in doc:
            pix = page.get_pixmap(matrix=fitz.Matrix(dpi/72, dpi/72))
            img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
            images.append(img)

        return images
```

---

## 2. 어노테이션 전략

### 2.1 어노테이션 형식

**Option 1: Key-Value 추출**
```json
{
    "image_path": "doc_001.png",
    "annotations": {
        "환자명": "홍길동",
        "생년월일": "1990-01-15",
        "진단명": "급성 상기도 감염",
        "진단일": "2024-01-20"
    }
}
```

**Option 2: Markdown 구조화**
```json
{
    "image_path": "doc_001.png",
    "markdown": "# 진단서\n\n## 환자 정보\n- 성명: 홍길동\n- 생년월일: 1990-01-15\n\n## 진단 내용\n- 진단명: 급성 상기도 감염\n- 진단일: 2024-01-20"
}
```

**Option 3: Conversation Format (VLM 학습용)**
```json
{
    "messages": [
        {
            "role": "user",
            "content": [
                {"type": "image", "image": "doc_001.png"},
                {"type": "text", "text": "이 진단서의 환자 정보와 진단 내용을 JSON으로 추출해주세요."}
            ]
        },
        {
            "role": "assistant",
            "content": "```json\n{\"환자명\": \"홍길동\", \"생년월일\": \"1990-01-15\", \"진단명\": \"급성 상기도 감염\", \"진단일\": \"2024-01-20\"}\n```"
        }
    ]
}
```

### 2.2 어노테이션 도구

```python
class AnnotationTool:
    """간단한 어노테이션 인터페이스"""

    def __init__(self, schema: dict):
        self.schema = schema
        self.annotations = []

    def annotate_document(self, image_path: str) -> dict:
        """대화형 어노테이션"""
        from PIL import Image
        import matplotlib.pyplot as plt

        # 이미지 표시
        img = Image.open(image_path)
        plt.figure(figsize=(12, 16))
        plt.imshow(img)
        plt.axis('off')
        plt.show()

        # 필드별 입력
        annotation = {"image_path": image_path}

        for field, field_info in self.schema.items():
            required = field_info.get("required", False)
            field_type = field_info.get("type", "text")

            prompt = f"{field}"
            if required:
                prompt += " (필수)"
            prompt += ": "

            value = input(prompt)

            if value or required:
                if field_type == "number":
                    value = float(value) if value else None
                annotation[field] = value

        self.annotations.append(annotation)
        return annotation

    def export(self, output_path: str):
        """어노테이션 내보내기"""
        import json
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(self.annotations, f, ensure_ascii=False, indent=2)


# 사용 예시
schema = {
    "document_type": {"type": "category", "options": ["진단서", "처방전", "영수증"], "required": True},
    "patient_name": {"type": "text", "required": True},
    "date": {"type": "date", "required": True},
    "diagnosis": {"type": "text", "required": False},
    "amount": {"type": "number", "required": False}
}

tool = AnnotationTool(schema)
```

### 2.3 Inter-Annotator Agreement

```python
from sklearn.metrics import cohen_kappa_score
import numpy as np

def calculate_agreement(annotator1: List[dict], annotator2: List[dict], field: str) -> float:
    """두 어노테이터 간 일치도 계산"""

    values1 = [a.get(field) for a in annotator1]
    values2 = [a.get(field) for a in annotator2]

    # 완전 일치율
    exact_match = sum(v1 == v2 for v1, v2 in zip(values1, values2)) / len(values1)

    # Cohen's Kappa (범주형 데이터)
    try:
        kappa = cohen_kappa_score(values1, values2)
    except:
        kappa = None

    return {
        "exact_match": exact_match,
        "cohens_kappa": kappa,
        "field": field
    }
```

---

## 3. 데이터 품질 관리

### 3.1 이미지 품질 검사

```python
import cv2
import numpy as np
from PIL import Image

class ImageQualityChecker:
    """이미지 품질 검사"""

    def __init__(self, min_resolution: int = 300, min_contrast: float = 0.3):
        self.min_resolution = min_resolution
        self.min_contrast = min_contrast

    def check_quality(self, image_path: str) -> dict:
        """품질 검사 수행"""
        img = cv2.imread(image_path)
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        results = {
            "image_path": image_path,
            "passed": True,
            "issues": []
        }

        # 1. 해상도 검사
        height, width = img.shape[:2]
        dpi_estimate = min(width, height) / 8.5  # A4 기준 추정
        if dpi_estimate < self.min_resolution:
            results["issues"].append(f"Low resolution: ~{dpi_estimate:.0f} DPI")
            results["passed"] = False

        # 2. 대비 검사
        contrast = gray.std() / 255.0
        if contrast < self.min_contrast:
            results["issues"].append(f"Low contrast: {contrast:.2f}")
            results["passed"] = False

        # 3. 흐림 검사 (Laplacian variance)
        blur_score = cv2.Laplacian(gray, cv2.CV_64F).var()
        if blur_score < 100:
            results["issues"].append(f"Blurry image: {blur_score:.1f}")
            results["passed"] = False

        # 4. 기울기 검사
        angle = self._detect_skew(gray)
        if abs(angle) > 5:
            results["issues"].append(f"Skewed: {angle:.1f}°")

        results["metrics"] = {
            "resolution": (width, height),
            "dpi_estimate": dpi_estimate,
            "contrast": contrast,
            "blur_score": blur_score,
            "skew_angle": angle
        }

        return results

    def _detect_skew(self, gray_image) -> float:
        """기울기 각도 검출"""
        edges = cv2.Canny(gray_image, 50, 150, apertureSize=3)
        lines = cv2.HoughLines(edges, 1, np.pi/180, 200)

        if lines is None:
            return 0.0

        angles = []
        for line in lines[:10]:  # 상위 10개 라인만
            rho, theta = line[0]
            angle = np.degrees(theta) - 90
            if -45 < angle < 45:
                angles.append(angle)

        return np.median(angles) if angles else 0.0

    def auto_correct(self, image_path: str, output_path: str) -> str:
        """자동 품질 보정"""
        img = cv2.imread(image_path)
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

        # 기울기 보정
        angle = self._detect_skew(gray)
        if abs(angle) > 1:
            center = (img.shape[1] // 2, img.shape[0] // 2)
            matrix = cv2.getRotationMatrix2D(center, angle, 1.0)
            img = cv2.warpAffine(img, matrix, (img.shape[1], img.shape[0]),
                                 borderMode=cv2.BORDER_REPLICATE)

        # 대비 향상
        lab = cv2.cvtColor(img, cv2.COLOR_BGR2LAB)
        l, a, b = cv2.split(lab)
        clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
        l = clahe.apply(l)
        enhanced = cv2.merge([l, a, b])
        img = cv2.cvtColor(enhanced, cv2.COLOR_LAB2BGR)

        cv2.imwrite(output_path, img)
        return output_path
```

### 3.2 텍스트 품질 검사

```python
class TextQualityChecker:
    """어노테이션 텍스트 품질 검사"""

    def __init__(self):
        self.required_fields = []
        self.validation_rules = {}

    def add_rule(self, field: str, rule_type: str, **kwargs):
        """검증 규칙 추가"""
        self.validation_rules[field] = {"type": rule_type, **kwargs}

    def validate(self, annotation: dict) -> dict:
        """어노테이션 검증"""
        issues = []

        for field, rule in self.validation_rules.items():
            value = annotation.get(field)

            if value is None:
                if rule.get("required", False):
                    issues.append(f"Missing required field: {field}")
                continue

            # 타입별 검증
            if rule["type"] == "date":
                if not self._validate_date(value):
                    issues.append(f"Invalid date format: {field}={value}")

            elif rule["type"] == "number":
                if not self._validate_number(value, rule.get("min"), rule.get("max")):
                    issues.append(f"Invalid number: {field}={value}")

            elif rule["type"] == "pattern":
                import re
                if not re.match(rule["pattern"], str(value)):
                    issues.append(f"Pattern mismatch: {field}={value}")

        return {
            "valid": len(issues) == 0,
            "issues": issues
        }

    def _validate_date(self, value: str) -> bool:
        """날짜 형식 검증"""
        import re
        patterns = [
            r'\d{4}-\d{2}-\d{2}',  # YYYY-MM-DD
            r'\d{4}/\d{2}/\d{2}',  # YYYY/MM/DD
            r'\d{4}\.\d{2}\.\d{2}' # YYYY.MM.DD
        ]
        return any(re.match(p, str(value)) for p in patterns)

    def _validate_number(self, value, min_val=None, max_val=None) -> bool:
        """숫자 범위 검증"""
        try:
            num = float(value)
            if min_val is not None and num < min_val:
                return False
            if max_val is not None and num > max_val:
                return False
            return True
        except:
            return False


# 사용 예시
checker = TextQualityChecker()
checker.add_rule("patient_name", "pattern", pattern=r"^[가-힣]{2,5}$", required=True)
checker.add_rule("birth_date", "date", required=True)
checker.add_rule("amount", "number", min=0, max=10000000)
```

---

## 4. 개인정보 처리

### 4.1 비식별화 전략

```python
import re
from typing import Dict, List
import hashlib

class Anonymizer:
    """개인정보 비식별화"""

    def __init__(self, salt: str = ""):
        self.salt = salt

        # 패턴 정의
        self.patterns = {
            "phone": r'01[0-9]-?\d{3,4}-?\d{4}',
            "email": r'[\w.-]+@[\w.-]+\.\w+',
            "rrn": r'\d{6}-?[1-4]\d{6}',  # 주민등록번호
            "card": r'\d{4}-?\d{4}-?\d{4}-?\d{4}'
        }

    def anonymize_text(self, text: str) -> Dict[str, str]:
        """텍스트 내 개인정보 비식별화"""
        anonymized = text
        mappings = {}

        for field_type, pattern in self.patterns.items():
            matches = re.finditer(pattern, anonymized)

            for match in matches:
                original = match.group()
                replacement = self._generate_replacement(original, field_type)
                mappings[replacement] = original
                anonymized = anonymized.replace(original, replacement, 1)

        return {
            "anonymized_text": anonymized,
            "mappings": mappings
        }

    def _generate_replacement(self, value: str, field_type: str) -> str:
        """대체값 생성"""
        # 해시 기반 가명처리
        hashed = hashlib.sha256((value + self.salt).encode()).hexdigest()[:8]
        return f"[{field_type.upper()}_{hashed}]"

    def anonymize_image(self, image_path: str, regions: List[tuple]) -> str:
        """이미지 내 영역 비식별화 (블러/마스킹)"""
        import cv2

        img = cv2.imread(image_path)

        for x, y, w, h in regions:
            # 가우시안 블러 적용
            roi = img[y:y+h, x:x+w]
            blurred = cv2.GaussianBlur(roi, (99, 99), 30)
            img[y:y+h, x:x+w] = blurred

        output_path = image_path.replace('.', '_anon.')
        cv2.imwrite(output_path, img)

        return output_path


# 사용 예시
anonymizer = Anonymizer(salt="my_secret_salt")
result = anonymizer.anonymize_text("환자 홍길동, 전화번호 010-1234-5678")
print(result["anonymized_text"])
# "환자 홍길동, 전화번호 [PHONE_a1b2c3d4]"
```

### 4.2 합성 데이터 활용

민감한 데이터 대신 합성 데이터 사용:

```python
from faker import Faker
import random

fake = Faker('ko_KR')

def generate_synthetic_medical_record() -> dict:
    """합성 의료 기록 생성"""
    return {
        "patient_name": fake.name(),
        "birth_date": fake.date_of_birth(minimum_age=1, maximum_age=100).isoformat(),
        "phone": fake.phone_number(),
        "address": fake.address(),
        "diagnosis": random.choice([
            "급성 상기도 감염",
            "고혈압",
            "제2형 당뇨병",
            "요추 추간판 탈출증",
            "위식도역류질환"
        ]),
        "diagnosis_date": fake.date_this_year().isoformat(),
        "doctor_name": fake.name(),
        "hospital_name": fake.company() + "병원"
    }
```

---

## 핵심 참고 자료

### 데이터셋
- **DocVQA**: https://www.docvqa.org/
- **RVL-CDIP**: Document Classification
- **FUNSD**: Form Understanding

### 도구
- **Label Studio**: https://labelstud.io/
- **CVAT**: https://www.cvat.ai/
- **Faker (Python)**: https://faker.readthedocs.io/

---

## 핵심 요약

| 단계 | 주요 작업 | 핵심 고려사항 |
|------|----------|--------------|
| 수집 | 스캔, 크롤링, API | 저작권, 품질 |
| 전처리 | 해상도, 기울기 보정 | 일관성 |
| 어노테이션 | 라벨링, 검증 | 일치도, 스키마 |
| 품질 관리 | 이미지/텍스트 검사 | 자동화 |
| 개인정보 | 비식별화, 합성 | 법적 요건 |
